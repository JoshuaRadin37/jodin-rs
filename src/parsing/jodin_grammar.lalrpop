use crate::core::identifier::Identifier;
use crate::core::error::{JodinError, JodinErrorType, JodinResult};
use crate::core::literal::Literal;
use crate::core::operator::Operator;
use crate::ast::{JodinNode, JodinNodeType, intermediate_type::IntermediateType};
use crate::parsing::Tok;

use super::UnwrapVector;//
use super::ParseResult;
use super::ExpressionMember;
use super::into_order_of_operations;

use std::iter::FromIterator;
use std::str::FromStr;



grammar<'input>(input: &'input str);



// atomic types
pub SingleIdentifier: Identifier =
    <s:"t_identifier"> => Identifier::from(s);

pub Identifier: Identifier = Joined<"t_identifier", "::"> => Identifier::from_iter(<>);



pub String: Literal = {
    "t_string_literal" => Literal::from_str(<>).unwrap(),
};

pub Literal: Literal = "t_constant" => {
    let lit = Literal::from_str(<>).unwrap();
    println!("Found literal: {:?}", lit);
    lit
};


pub IdentifierList = OptionalList<Identifier>;

pub CanonicalType: JodinResult<IntermediateType> = { }

pub Expression: JodinResult<JodinNode> = {
    ExpressionWrapper,
    <cond:ExpressionWrapper> "?" <t:Expression> ":" <f:Expression> => {
        JodinNodeType::Ternary {
            cond: cond?,
            yes: t?,
            no: f?
        }.into_result()
    }
}

ExpressionWrapper: JodinResult<JodinNode> = {
    BinopExpression => {
        Ok(into_order_of_operations(<>?))
    }
}

BinopExpression: JodinResult<Vec<ExpressionMember>> = {
    // Factor => Ok(vec![ExpressionMember::Factor(<>?)]),
    <hd:Factor> <tails:BinopTail*> => {
        let mut first = vec![ExpressionMember::Factor(hd?)];
        for tail in tails {
            first.extend(tail?);
        }
        Ok(first)
    }
}

BinopTail:  JodinResult<Vec<ExpressionMember>> = {
    <op:"t_operator"> <tl:Factor> => {
        Ok(vec![ExpressionMember::Op(op), ExpressionMember::Factor(tl?)])
    }
}

pub UniOp: ParseResult = {
    "++" <Factor> => JodinNodeType::Uniop { op: Operator::Increment, inner: <>?}.into_result(),
    "--" <Factor> => JodinNodeType::Uniop { op: Operator::Decrement, inner: <>?}.into_result(),
}

pub Factor:  ParseResult = {
    UniOp,
    String => JodinNodeType::Literal(<>).into_result(),
    Literal => JodinNodeType::Literal(<>).into_result(),
    "true" => JodinNodeType::Literal(Literal::Boolean(true)).into_result(),
    "false" => JodinNodeType::Literal(Literal::Boolean(false)).into_result(),
    CastExpression,
    AtomModifier
}

CastExpression: ParseResult = "(" <c_type:CanonicalType> ")" <factor:Factor> => JodinNodeType::CastExpression {
    to_type: c_type?,
    factor: factor?
 }.into_result();

Atom: JodinResult<JodinNode> = {
    "(" <Expression> ")",
    Identifier => JodinNodeType::Identifier(<>).into_result(),
    "new" <ty:CanonicalType> <generics:GenericInstance?> "(" <args:ArgsList> ")" => {
        JodinNodeType::ConstructorCall {
            name: ty?,
            generic_parameters: generics.unwrap_or(vec![]).unwrap_vec()?,
            arguments: args.unwrap_vec()?
        }.into_result()
    }
}

pub AtomModifier: ParseResult = {
    <atom: AtomModifier> <call: FunctionCall> => {
        let (generics, arguments) = call?;
        JodinNodeType::Call {
            called: atom?,
            generics_instance: generics,
            arguments
        }.into_result()
    },
    <atom: AtomModifier> <index: GetIndex> => {
        JodinNodeType::Index {
            indexed: atom?,
            expression: index?
        }.into_result()
    },
    <atom: AtomModifier> "." <field: SingleIdentifier> => {

            JodinNodeType::GetMember {
                compound: atom?,
                id: JodinNodeType::Identifier(field).into()
            }.into_result()

    },
    Atom,
}


GenericInstance = "<" <OptionalList<CanonicalType>> ">";


ArgsList = OptionalList<Expression>;

FunctionCall: JodinResult<(Vec<JodinNode>, Vec<JodinNode>)> = {
    "(" <args: ArgsList> ")" => {
        let args = args.unwrap_vec()?;
        Ok((vec![], args))
    }
}

GetIndex: JodinResult<JodinNode> = {
    "[" <node:Expression> "]" => node
}

pub Statement: ParseResult = {
    AssignmentStatement,
}

AssignmentStatement: ParseResult = {
    <atom:AtomModifier> <assign:"t_assign"> <exp:Expression> ";" => {
        JodinNodeType::AssignmentExpression {
            maybe_assignment_operator: assign,
            lhs: atom?,
            rhs: exp?
        }.into_result()
    }
}





pub JodinFile: JodinResult<JodinNode> = TopLevelDeclarations;

pub TopLevelDeclarations: JodinResult<JodinNode> = {
    <decs:TopLevelDeclarationsList> => JodinNodeType::TopLevelDeclarations {decs: decs? }.into_result()
}

TopLevelDeclarationsList: JodinResult<Vec<JodinNode>> = {
  <dec:TopLevelDeclaration> => Ok(vec![dec?]),
  <v:TopLevelDeclarationsList> <dec:TopLevelDeclaration> => {
    let mut vector = v?;
    vector.push(dec?);
    Ok(vector)
  }
};


pub TopLevelDeclaration: JodinResult<JodinNode> = {

    ";" => JodinNodeType::Empty.into_result()
};






// macros



Joined<T, Seperator>: Vec<T> = {
    <v:T> => vec![v],
    <mut hd:Joined<T, Seperator>> <u:Seperator> <tl:T> => {
        hd.push(tl);
        hd
    }
}


List<T>: Vec<T> = Joined<T, ",">;

Optional<T>: Option<T> = {
    <v:T?> => v
};

OptionalJoined<T, Seperator>: Vec<T> = {
    <list:Optional<Joined<T, Seperator>>> =>
    match list {
        Some(list) => list,
        None => vec![]
    }
};

OptionalList<T>: Vec<T> = OptionalJoined<T, ",">;


Tier<Op, NextTier>: JodinResult<JodinNode> = {
    <rhs:Tier<Op,NextTier>> <op:Op> <lhs:NextTier>  => {
        println!("parsed {:?} expression", op);
        JodinNodeType::Binop { op, lhs: lhs?, rhs: rhs? }.into_result()
    },
    NextTier
};

DerefOp<Op>: Operator = <op:Op> => if let Tok::Operator(op) = op {
    op
 } else {
    panic!()
 };

extern {
    type Location = usize;
    type Error = crate::core::error::JodinError;

    enum Tok<'input> {
        "t_constant" => Tok::Constant(<&'input str>),
        "t_identifier" => Tok::Identifier(<&'input str>),
        "t_string_literal" => Tok::StringLiteral(<&'input str>),
        "t_operator" => Tok::Op(<Operator>),
        ">" => Tok::Op(Operator::Gt),
        "<" => Tok::Op(Operator::Lt),
        "++" => Tok::Increment,
        "--" => Tok::Decrement,
        "t_assign" => Tok::Assign(<Option<Operator>>),
        "break" => Tok::Break,
        "case" => Tok::Case,
        "char" => Tok::Char,
        "const" => Tok::Const,
        "continue" => Tok::Continue,
        "default" => Tok::Default,
        "double" => Tok::Double,
        "do" => Tok::Do,
        "else" => Tok::Else,
        "float" => Tok::Float,
        "for" => Tok::For,
        "if" => Tok::If,
        "int" => Tok::Int,
        "long" => Tok::Long,
        "return" => Tok::Return,
        "short" => Tok::Short,
        "static" => Tok::Static,
        "typedef" => Tok::Typedef,
        "union" => Tok::Union,
        "unsigned" => Tok::Unsigned,
        "struct" => Tok::Struct,
        "void" => Tok::Void,
        "while" => Tok::While,
        "class" => Tok::Class,
        "public" => Tok::Public,
        "private" => Tok::Private,
        "new" => Tok::New,
        "super" => Tok::Super,
        "virtual" => Tok::Virtual,
        "sizeof" => Tok::Sizeof,
        "boolean" => Tok::Boolean,
        "in" => Tok::In,
        "implement" => Tok::Implement,
        "internal" => Tok::Internal,
        "using" => Tok::Using,
        "typeof" => Tok::Typeof,
        "true" => Tok::True,
        "false" => Tok::False,
        "abstract" => Tok::Abstract,
        "is" => Tok::Is,
        "trait" => Tok::Trait,
        "enum" => Tok::Enum,
        "switch" => Tok::Switch,
        "as" => Tok::As,
        "..." => Tok::Varargs,
        "::" => Tok::Namespaced,
        "," => Tok::Comma,
        ";" => Tok::Semic,
        "(" => Tok::LPar,
        ")" => Tok::RPar,
        "[" => Tok::LBrac,
        "]" => Tok::RBrac,
        "{" => Tok::LCurl,
        "}" => Tok::RCurl,
        ":" => Tok::Colon,
        "?" => Tok::Qmark,
        "." => Tok::Dot
    }
}