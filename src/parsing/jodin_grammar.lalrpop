use crate::core::identifier::Identifier;
use crate::core::error::{JodinError, JodinErrorType, JodinResult};
use crate::core::literal::Literal;
use crate::core::operator::Operator;
use crate::ast::{JodinNode, JodinNodeType, intermediate_type::IntermediateType};
use crate::parsing::Tok;

use super::UnwrapVector;
use super::ParseResult;

use std::iter::FromIterator;
use std::str::FromStr;



grammar<'input>(input: &'input str);



// atomic types
pub SingleIdentifier: Identifier =
    <s:"t_identifier"> => Identifier::from(s);

pub Identifier: Identifier = Joined<"t_identifier", "::"> => Identifier::from_iter(<>);



pub String: Literal = {
    "t_string_literal" => Literal::from_str(<>).unwrap(),
};

pub Literal: Literal = "t_constant" => Literal::from_str(<>).unwrap();


pub IdentifierList = OptionalList<Identifier>;

pub CanonicalType: JodinResult<IntermediateType> = { }

pub Expression: JodinResult<JodinNode> = {
    DorExpression,
    <cond:DorExpression> "?" <t:Expression> ":" <f:Expression> => {
        JodinNodeType::Ternary {
            cond: cond?,
            yes: t?,
            no: f?
        }.into_result()
    }
}

DorExpression = Tier<"||", DandExpression>;

DandExpression = Tier<"&&", OrExpression>;

OrExpression = Tier<"|", XorExpression>;

XorExpression = Tier<"^", AndExpression>;

AndExpression = Tier<"&", EqualityExpression>;

EqualityExpression = Tier<EqualityOps, ComparisonExpression>;

EqualityOps: Operator = {
    "!=" => Operator::Nequal,
    "==" => Operator::Equal
}

ComparisonExpression = Tier<ComparisonOps, ShiftExpression>;

ComparisonOps: Operator = {
    "<" => Operator::Lt,
    "<=" => Operator::Lte,
    ">" => Operator::Gt,
    ">=" => Operator::Gte,

}

ShiftExpression = Tier<ShiftOps, AddExpression>;

ShiftOps: Operator = {
    ">>" => Operator::RShift,
    "<<" => Operator::LShift
}

AddExpression = Tier<AddOps, MultExpression>;

AddOps: Operator = {
    "+" => Operator::Plus,
    "-" => Operator::Minus
}

MultExpression = Tier<MultOps, Factor>;

MultOps: Operator = {
    "*" => Operator::Star,
    "/" => Operator::Divide,
    "%" => Operator::Modulo
}

pub UniOp: ParseResult = {
    "++" <Factor> => JodinNodeType::Uniop { op: Operator::Increment, inner: <>?}.into_result(),
    "--" <Factor> => JodinNodeType::Uniop { op: Operator::Decrement, inner: <>?}.into_result(),
}

pub Factor:  ParseResult = {
    UniOp,
    String => JodinNodeType::Literal(<>).into_result(),
    Literal => JodinNodeType::Literal(<>).into_result(),
    "true" => JodinNodeType::Literal(Literal::Boolean(true)).into_result(),
    "false" => JodinNodeType::Literal(Literal::Boolean(false)).into_result(),
    CastExpression,
    AtomModifier
}

CastExpression: ParseResult = "(" <c_type:CanonicalType> ")" <factor:Factor> => JodinNodeType::CastExpression {
    to_type: c_type?,
    factor: factor?
 }.into_result();

Atom: JodinResult<JodinNode> = {
    "(" <Expression> ")",
    Identifier => JodinNodeType::Identifier(<>).into_result(),
    "new" <ty:CanonicalType> <generics:GenericInstance?> "(" <args:ArgsList> ")" => {
        JodinNodeType::ConstructorCall {
            name: ty?,
            generic_parameters: generics.unwrap_or(vec![]).unwrap_vec()?,
            arguments: args.unwrap_vec()?
        }.into_result()
    }
}

pub AtomModifier: ParseResult = {
    <atom: Atom> <call: FunctionCall> => {
        let (generics, arguments) = call?;
        JodinNodeType::Call {
            called: atom?,
            generics_instance: generics,
            arguments
        }.into_result()
    },
    Atom,
}


GenericInstance = "<" <OptionalList<CanonicalType>> ">";


ArgsList = OptionalList<Expression>;

FunctionCall: JodinResult<(Vec<JodinNode>, Vec<JodinNode>)> = {
    "(" <args: ArgsList> ")" => {
        let args = args.unwrap_vec()?;
        Ok((vec![], args))
    }
}





pub JodinFile: JodinResult<JodinNode> = TopLevelDeclarations;

pub TopLevelDeclarations: JodinResult<JodinNode> = {
    <decs:TopLevelDeclarationsList> => JodinNodeType::TopLevelDeclarations {decs: decs? }.into_result()
}

TopLevelDeclarationsList: JodinResult<Vec<JodinNode>> = {
  <dec:TopLevelDeclaration> => Ok(vec![dec?]),
  <v:TopLevelDeclarationsList> <dec:TopLevelDeclaration> => {
    let mut vector = v?;
    vector.push(dec?);
    Ok(vector)
  }
};


pub TopLevelDeclaration: JodinResult<JodinNode> = {

    ";" => JodinNodeType::Empty.into_result()
};






// macros



Joined<T, Seperator>: Vec<T> = {
    <v:T> => vec![v],
    <mut hd:Joined<T, Seperator>> <u:Seperator> <tl:T> => {
        hd.push(tl);
        hd
    }
}


List<T>: Vec<T> = Joined<T, ",">;

Optional<T>: Option<T> = {
    <v:T?> => v
};

OptionalJoined<T, Seperator>: Vec<T> = {
    <list:Optional<Joined<T, Seperator>>> =>
    match list {
        Some(list) => list,
        None => vec![]
    }
};

OptionalList<T>: Vec<T> = OptionalJoined<T, ",">;


Tier<Op, NextTier>: JodinResult<JodinNode> = {
    <lhs:Tier<Op,NextTier>> <op:Op> <rhs:NextTier> => JodinNodeType::Binop { op, lhs: lhs?, rhs: rhs? }.into_result(),
    NextTier
};


extern {
    type Location = usize;
    type Error = crate::core::error::JodinError;

    enum Tok<'input> {
        "t_constant" => Tok::Constant(<&'input str>),
        "t_identifier" => Tok::Identifier(<&'input str>),
        "t_string_literal" => Tok::StringLiteral(<&'input str>),
        "t_operator" => Tok::Operator(<Operator>),
        "||" => Operator::Dor,
        "++" => Tok::Operator(Operator::Increment),
        "--" => Tok::Operator(Operator::Decrement),
        "*" => Tok::Operator(Operator::Star),
        "/" => Tok::Operator(Operator::Divide),
        "%" => Tok::Operator(Operator::Modulo),
        "+" => Tok::Operator(Operator::Plus),
        "-" => Tok::Operator(Operator::Minus),
        ">>" => Tok::Operator(Operator::RShift),
        "<<" => Tok::Operator(Operator::LShift),
        ">=" => Tok::Operator(Operator::Gte),
        "<=" => Tok::Operator(Operator::Lte),
        "!=" => Tok::Operator(Operator::Nequal),
        "==" => Tok::Operator(Operator::Equal),
        ">" => Tok::Operator(Operator::Gt),
        "<" => Tok::Operator(Operator::Lt),
        "&" => Tok::Operator(Operator::And),
        "&&" => Tok::Operator(Operator::Dand),
        "|" => Tok::Operator(Operator::Or),
        "||" => Tok::Operator(Operator::Dor),
        "^" => Tok::Operator(Operator::Xor),
        "t_assign" => Tok::Assign(<Option<Operator>>),
        "break" => Tok::Break,
        "case" => Tok::Case,
        "char" => Tok::Char,
        "const" => Tok::Const,
        "continue" => Tok::Continue,
        "default" => Tok::Default,
        "double" => Tok::Double,
        "do" => Tok::Do,
        "else" => Tok::Else,
        "float" => Tok::Float,
        "for" => Tok::For,
        "if" => Tok::If,
        "int" => Tok::Int,
        "long" => Tok::Long,
        "return" => Tok::Return,
        "short" => Tok::Short,
        "static" => Tok::Static,
        "typedef" => Tok::Typedef,
        "union" => Tok::Union,
        "unsigned" => Tok::Unsigned,
        "struct" => Tok::Struct,
        "void" => Tok::Void,
        "while" => Tok::While,
        "class" => Tok::Class,
        "public" => Tok::Public,
        "private" => Tok::Private,
        "new" => Tok::New,
        "super" => Tok::Super,
        "virtual" => Tok::Virtual,
        "sizeof" => Tok::Sizeof,
        "boolean" => Tok::Boolean,
        "in" => Tok::In,
        "implement" => Tok::Implement,
        "internal" => Tok::Internal,
        "using" => Tok::Using,
        "typeof" => Tok::Typeof,
        "true" => Tok::True,
        "false" => Tok::False,
        "abstract" => Tok::Abstract,
        "is" => Tok::Is,
        "trait" => Tok::Trait,
        "enum" => Tok::Enum,
        "switch" => Tok::Switch,
        "as" => Tok::As,
        "..." => Tok::Varargs,
        "::" => Tok::Namespaced,
        "," => Tok::Comma,
        ";" => Tok::Semic,
        "(" => Tok::LPar,
        ")" => Tok::RPar,
        ":" => Tok::Colon,
        "?" => Tok::Qmark
    }
}